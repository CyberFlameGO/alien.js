<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Alien.js â€” 3D Ripple</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
    <div id="root"></div>
    <script type="module">import{Assets,Color,DirectionalLight,Events,Group,Interface,LinearFilter,Mesh,MeshStandardMaterial,PerspectiveCamera,PlaneGeometry,Scene,Stage,Texture,Uniform,Vector2,WebGL1Renderer,clearTween,delayedCall,getFrustum,ticker}from"../build/alien.js";class Config{}Config.BG_COLOR="#0e0e0e",Config.UI_COLOR="rgba(255, 255, 255, 0.94)";class GridCanvas extends Interface{constructor(){super(null,"canvas"),this.resize=(e,t,i)=>{this.width=e,this.height=t,this.element.width=Math.round(e*i),this.element.height=Math.round(t*i),this.context.scale(i,i),this.update()},this.update=()=>{this.context.clearRect(0,0,this.width,this.height),this.drawGrid()},this.initCanvas(),this.initGrid()}initCanvas(){this.context=this.element.getContext("2d")}initGrid(){this.grid={fillStyle:Config.BG_COLOR,strokeStyle:Config.UI_COLOR}}drawGrid(){this.context.fillStyle=this.grid.fillStyle,this.context.strokeStyle=this.grid.strokeStyle,this.context.fillRect(0,0,this.width,this.height),this.context.beginPath();for(let e=0;e<this.width;e+=this.width/10)this.context.moveTo(e,0),this.context.lineTo(e,this.height);for(let e=0;e<this.height;e+=this.height/10)this.context.moveTo(0,e),this.context.lineTo(this.width,e);this.context.stroke()}}class SceneView extends Group{constructor(){super(),this.resize=()=>{const{width:e,height:t,dpr:i}=Stage;this.grid.resize(e,t,i),this.resizeCanvas("displace",e,t,i),this.resizeCanvas("ripple",256,256,i),this.texture.grid.needsUpdate=!0,this.isLoaded&&(this.context.ripple.drawImage(this.image.ripple,0,0,this.canvas.ripple.width,this.canvas.ripple.height),this.update()),this.multiplier=e<t?.5:1,this.material.displacementScale=5*this.multiplier;const s=WorldController.getFrustum();this.mesh.scale.set(s.width,s.height,1)},this.update=()=>{this.visible&&(this.drawDisplace(),this.texture.displace.needsUpdate=!0)},this.addRipple=(e=1,t=0,i=0)=>{this.ripples.push({direction:e,x:e>0?-.5:1.5,y:.5,skew:.5*Math.random()*t,scale:1.5,alpha:1,frame:i,random:Math.random()})},this.wave=e=>{this.addRipple(e,1,0),this.addRipple(e,-1,10*Math.random()+5),this.needsUpdate=!0},this.canvas={},this.context={},this.texture={},this.image={},this.ripples=[],this.multiplier=1,this.needsUpdate=!1,this.isLoaded=!1,this.visible=!1,this.initCanvas(),this.initMesh()}initCanvas(){this.grid=new GridCanvas,this.createCanvas("displace"),this.createCanvas("ripple")}initMesh(){this.texture.grid=new Texture(this.grid.element),this.texture.grid.minFilter=LinearFilter,this.texture.grid.generateMipmaps=!1,this.texture.displace=new Texture(this.canvas.displace),this.texture.displace.minFilter=LinearFilter,this.texture.displace.generateMipmaps=!1,this.material=new MeshStandardMaterial({map:this.texture.grid,displacementMap:this.texture.displace,displacementScale:.3,transparent:!0,depthWrite:!1,depthTest:!1}),this.mesh=new Mesh(new PlaneGeometry(1,1,64,64),this.material),this.mesh.frustumCulled=!1,this.add(this.mesh)}async initImages(){const e=Date.now(),t=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024"><filter id="ripple-${e}"><feGaussianBlur in="SourceGraphic" stdDeviation="16"/></filter><g fill="none" filter="url(#ripple-${e})"><rect width="100%" height="100%"></rect><circle cx="512" cy="512" r="256" stroke="#fff" stroke-width="64"/></g></svg>`;await Promise.all([this.loadImage("ripple","data:image/svg+xml;base64,"+btoa(t))]),this.isLoaded=!0,this.resize()}async loadImage(e,t){const i=await Assets.loadImage(t);return this.image[e]=i,i}createCanvas(e){this.canvas[e]=document.createElement("canvas"),this.context[e]=this.canvas[e].getContext("2d")}resizeCanvas(e,t,i,s){this.canvas[e].width=Math.round(t*s),this.canvas[e].height=Math.round(i*s)}updateRipples(){const calc=(e,t,i,s)=>i*Math.sin(e/s*(Math.PI/2))+t;let e=0;this.ripples.forEach((t,i)=>{if(t.frame++>=0){const s=t.frame;t.x=t.direction>0?-.5+calc(s,0,1,260):1.5-calc(s,0,1,260),t.scale=1.5+calc(s,0,12*this.multiplier,260),t.alpha=s>200?1-calc(s-200,0,1,60):1,s>=260&&(this.ripples.splice(i-e++,1),this.ripples.length||(this.needsUpdate=!1))}})}drawDisplace(){this.context.displace.fillRect(0,0,this.canvas.displace.width,this.canvas.displace.height),this.updateRipples(),this.ripples.forEach(e=>{const t=this.canvas.ripple.width*e.scale,i=this.canvas.ripple.height*e.scale;this.context.displace.save(),this.context.displace.translate(this.canvas.displace.width*e.x,this.canvas.displace.height*e.y),this.context.displace.transform(1,e.skew,0,1+e.random,0,0),this.context.displace.globalAlpha=e.alpha,this.context.displace.drawImage(this.canvas.ripple,-t/2,-i/2,t,i),this.context.displace.restore()})}}class SceneController{static init(e){this.view=e,this.mouse=new Vector2,this.last=new Vector2,this.delta=new Vector2,this.mouse.set(Stage.width/2,Stage.height/2),this.last.copy(this.mouse),this.timeout=!1,this.addListeners(),this.constantWaving()}static addListeners(){Stage.events.on(Events.VISIBILITY,this.onVisibility),Stage.element.addEventListener("touchstart",this.onTouchStart),Stage.element.addEventListener("mousedown",this.onTouchStart),window.addEventListener("touchmove",this.onTouchMove),window.addEventListener("mousemove",this.onTouchMove)}}SceneController.onVisibility=()=>{document.hidden?clearTween(SceneController.constant):SceneController.constantWaving()},SceneController.onTouchStart=e=>{e.preventDefault(),SceneController.onTouchMove(e)},SceneController.onTouchMove=e=>{if(!SceneController.view.visible)return;const t={};e.changedTouches&&e.changedTouches.length?(t.x=e.changedTouches[0].clientX,t.y=e.changedTouches[0].clientY):(t.x=e.clientX,t.y=e.clientY),SceneController.mouse.copy(t),SceneController.delta.subVectors(SceneController.mouse,SceneController.last),SceneController.last.copy(SceneController.mouse),SceneController.timeout||(SceneController.timeout=!0,SceneController.view.wave(SceneController.delta.x>0?1:-1),delayedCall(2500,()=>{SceneController.timeout=!1}))},SceneController.resize=()=>{SceneController.view.resize()},SceneController.update=()=>{SceneController.view.needsUpdate&&SceneController.view.update()},SceneController.constantWaving=()=>{SceneController.view.wave(1),SceneController.constant=delayedCall(1e3*Math.random()+1e3,SceneController.constantWaving)},SceneController.animateIn=()=>{SceneController.view.visible=!0},SceneController.ready=()=>SceneController.view.initImages();class RenderManager{static init(e,t,i){this.renderer=e,this.scene=t,this.camera=i,this.initRenderer()}static initRenderer(){}}RenderManager.resize=(e,t,i)=>{RenderManager.renderer.setPixelRatio(i),RenderManager.renderer.setSize(e,t)},RenderManager.update=()=>{RenderManager.renderer.render(RenderManager.scene,RenderManager.camera)};class WorldController{static init(){this.initWorld(),this.initLights()}static initWorld(){this.renderer=new WebGL1Renderer({powerPreference:"high-performance",stencil:!1}),this.element=this.renderer.domElement,this.scene=new Scene,this.scene.background=new Color(Config.BG_COLOR),this.camera=new PerspectiveCamera(25),this.camera.near=.1,this.camera.far=1e3,this.camera.position.z=100,this.resolution=new Uniform(new Vector2),this.aspect=new Uniform(1),this.time=new Uniform(0),this.frame=new Uniform(0)}static initLights(){const e=new DirectionalLight(16777215);e.position.set(1,1,1),this.scene.add(e)}}WorldController.resize=(e,t,i)=>{WorldController.camera.aspect=e/t,WorldController.camera.updateProjectionMatrix(),e=Math.round(e*i),t=Math.round(t*i),WorldController.resolution.value.set(e,t),WorldController.aspect.value=e/t},WorldController.update=(e,t,i)=>{WorldController.time.value=e,WorldController.frame.value=i},WorldController.getFrustum=()=>getFrustum(WorldController.camera);class App{static async init(){this.initWorld(),this.initViews(),this.initControllers(),this.addListeners(),this.onResize(),await SceneController.ready(),SceneController.animateIn()}static initWorld(){WorldController.init(),Stage.add(WorldController.element)}static initViews(){this.view=new SceneView,WorldController.scene.add(this.view)}static initControllers(){const{renderer:e,scene:t,camera:i}=WorldController;SceneController.init(this.view),RenderManager.init(e,t,i)}static addListeners(){Stage.events.on(Events.RESIZE,this.onResize),ticker.add(this.onUpdate)}}App.onResize=()=>{const{width:e,height:t,dpr:i}=Stage;WorldController.resize(e,t,i),SceneController.resize(),RenderManager.resize(e,t,i)},App.onUpdate=(e,t,i)=>{WorldController.update(e,t,i),SceneController.update(),RenderManager.update(e,t,i)},App.init();</script>
</body>
</html>

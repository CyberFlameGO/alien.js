<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Alien.js â€” Post-processing Depth of Field</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
    <div id="root"></div>
    <script type="module">import{ACESFilmicToneMapping,AdditiveBlending,AmbientLight,BloomCompositeMaterial,BlurDirectionX,BlurDirectionY,BufferAttribute,BufferGeometry,Color,CopyMaterial,DepthTexture,Device,DirectionalLight,EnvironmentTextureLoader,Events,FXAAMaterial,Group,HemisphereLight,ImageBitmapLoaderThread,LuminosityMaterial,MathUtils,Mesh,MeshStandardMaterial,NoBlending,OrbitControls,OrthographicCamera,PerspectiveCamera,Points,RGBFormat,RawShaderMaterial,Scene,SceneCompositeMaterial,SphericalCubeTextureLoader,Stage,TextureLoader,Thread,Uniform,UnrealBloomBlurMaterial,Vector2,WebGL1Renderer,WebGLRenderTarget,getFullscreenTriangle,getSphericalCube,mix,ticker}from"../build/alien.js";class Config{}Config.BG_COLOR="#0e0e0e",Config.UI_COLOR="rgba(255, 255, 255, 0.94)",Config.DEBUG="?debug"===location.search;const vertexBokehBlur1Shader="\n            attribute vec2 uv;\n            attribute vec3 position;\n\n            varying vec2 vUv;\n\n            void main() {\n                vUv = uv;\n\n                gl_Position = vec4(position, 1.0);\n            }\n        ",fragmentBokehBlur1Shader="\n            precision highp float;\n\n            #define PI          3.14\n            #define TWO_PI      6.28\n            #define MAX_SAMPLES 28.0\n\n            uniform sampler2D tMap;\n            uniform float uPower;\n            uniform float uAmount;\n            uniform vec2 uResolution;\n\n            varying vec2 vUv;\n\n            const float blurRadMax = 0.08;\n            const float blurCircles = 4.0;\n\n            void main() {\n                vec2 uv = vUv - 0.5;\n                uv.x *= uResolution.x / uResolution.y;\n                uv += 0.5;\n\n                float amount = length(uv - 0.5);\n                amount = pow(amount, uPower);\n                amount *= uAmount;\n\n                float blurRadius = blurRadMax * amount;\n\n                float totalSamples = 0.0;\n                vec3 colAcum = vec3(0.0);\n\n                for (float currentCircle = 0.0; currentCircle < blurCircles; currentCircle++) {\n                    float samplesForCurrentCircle = (pow(currentCircle + 1.0, 2.0) - pow(currentCircle, 2.0)) * 4.0;\n                    float currentRadius = (blurRadius / blurCircles) * (currentCircle + 0.5);\n\n                    for (float currentSample = 0.0; currentSample < MAX_SAMPLES; currentSample++) {\n                        if (currentSample >= samplesForCurrentCircle) break;\n\n                        vec2 samplePoint = vec2(0.0, currentRadius);\n                        float angle = TWO_PI * ((currentSample + 0.5) / samplesForCurrentCircle);\n\n                        float s = sin(angle);\n                        float c = cos(angle);\n                        mat2 m = mat2(c, -s, s, c);\n                        samplePoint = m * samplePoint;\n\n                        samplePoint *= vec2(uResolution.y / uResolution.x, 1.0);\n\n                        totalSamples++;\n                        colAcum += texture2D(tMap, vUv + samplePoint, blurRadius * 30.0).rgb;\n                    }\n                }\n\n                gl_FragColor = vec4(colAcum / totalSamples, 1.0);\n            }\n        ";class BokehBlurMaterial1 extends RawShaderMaterial{constructor(){super({uniforms:{tMap:new Uniform(null),uPower:new Uniform(3),uAmount:new Uniform(1),uResolution:new Uniform(new Vector2)},vertexShader:vertexBokehBlur1Shader,fragmentShader:fragmentBokehBlur1Shader,blending:NoBlending,depthWrite:!1,depthTest:!1})}}const vertexBokehBlur2Shader="\n            attribute vec2 uv;\n            attribute vec3 position;\n\n            varying vec2 vUv;\n\n            void main() {\n                vUv = uv;\n\n                gl_Position = vec4(position, 1.0);\n            }\n        ",fragmentBokehBlur2Shader="\n            precision highp float;\n\n            #define PI          3.14\n            #define TWO_PI      6.28\n            #define MAX_SAMPLES 20.0\n\n            uniform sampler2D tMap;\n            uniform float uPower;\n            uniform float uAmount;\n            uniform float uDebug;\n            uniform vec2 uResolution;\n\n            varying vec2 vUv;\n\n            const float blurRadMax = 0.08;\n            const float blurCircles = 3.0;\n\n            void main() {\n                vec2 uv = vUv - 0.5;\n                uv.x *= uResolution.x / uResolution.y;\n                uv += 0.5;\n\n                float amount = length(uv - 0.5);\n                amount = pow(amount, uPower);\n                amount *= uAmount;\n\n                float blurRadius = blurRadMax * amount * 0.3;\n\n                float totalSamples = 0.0;\n                vec3 colAcum = vec3(0.0);\n\n                for (float currentCircle = 0.0; currentCircle < blurCircles; currentCircle++) {\n                    float samplesForCurrentCircle = (pow(currentCircle + 1.0, 2.0) - pow(currentCircle, 2.0)) * 4.0;\n                    float currentRadius = (blurRadius / blurCircles) * (currentCircle + 0.5);\n\n                    for (float currentSample = 0.0; currentSample < MAX_SAMPLES; currentSample++) {\n                        if (currentSample >= samplesForCurrentCircle) break;\n\n                        vec2 samplePoint = vec2(0.0, currentRadius);\n                        float angle = TWO_PI * ((currentSample + 0.5) / samplesForCurrentCircle);\n\n                        float s = sin(angle);\n                        float c = cos(angle);\n                        mat2 m = mat2(c, -s, s, c);\n                        samplePoint = m * samplePoint;\n\n                        samplePoint *= vec2(uResolution.y / uResolution.x, 1.0);\n\n                        totalSamples++;\n                        colAcum = max(colAcum, texture2D(tMap, vUv + samplePoint).rgb);\n                    }\n                }\n\n                gl_FragColor = vec4(mix(colAcum, vec3(amount), uDebug), 1.0);\n            }\n        ";class BokehBlurMaterial2 extends RawShaderMaterial{constructor(){super({uniforms:{tMap:new Uniform(null),uPower:new Uniform(3),uAmount:new Uniform(1),uDebug:new Uniform(Config.DEBUG?1:0),uResolution:new Uniform(new Vector2)},vertexShader:vertexBokehBlur2Shader,fragmentShader:fragmentBokehBlur2Shader,blending:NoBlending,depthWrite:!1,depthTest:!1})}}import simplex3d from"../src/shaders/modules/noise/simplex3d.glsl.js";import depth from"../src/shaders/modules/depth/depth.glsl.js";const vertexDustShader=`\n            attribute vec3 position;\n\n            uniform mat4 projectionMatrix;\n            uniform mat4 modelViewMatrix;\n            uniform mat4 modelMatrix;\n            uniform vec3 cameraPosition;\n\n            uniform float uScale;\n            uniform float uCameraNear;\n            uniform float uCameraFar;\n            uniform float uTime;\n\n            varying float vFade;\n\n            ${simplex3d}\n\n            void main() {\n                vec3 p = position;\n                p.x += snoise(position.xyz + uTime * 0.02);\n                p.y += snoise(position.yyz + uTime * 0.02);\n                p.z += snoise(position.zxy + uTime * 0.02);\n\n                vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);\n\n                gl_PointSize = uScale * (150.0 / -mvPosition.z);\n                gl_Position = projectionMatrix * mvPosition;\n\n                vec3 pos = (modelMatrix * vec4(p, 1.0)).xyz;\n                float linearDepth = 1.0 / (uCameraFar - uCameraNear);\n                float linearPos = length(cameraPosition - pos) * linearDepth;\n\n                vFade = 1.0 - linearPos * 0.75;\n                vFade *= smoothstep(0.09, 0.13, linearPos);\n            }\n        `,fragmentDustShader=`\n            precision highp float;\n\n            #include <packing>\n\n            uniform sampler2D tMap;\n            uniform sampler2D tDepth;\n            uniform float uAlpha;\n            uniform float uCameraNear;\n            uniform float uCameraFar;\n            uniform vec2 uResolution;\n\n            varying float vFade;\n\n            ${depth}\n\n            float fadeEdge(float particleDepth, float sceneDepth) {\n                // Margin makes it blend through the solid objects a little bit more, creating illusion of density\n                float extraMargin = 0.015;\n                float a = (sceneDepth + extraMargin - particleDepth) * 120.0;\n                if (a <= 0.0) return 0.0;\n                if (a >= 1.0) return 1.0;\n\n                if (a < 0.5) a = 2.0 * a * a;\n                else a = -2.0 * pow(a - 1.0, 2.0) + 1.0;\n\n                return a;\n            }\n\n            void main() {\n                vec4 tex = texture2D(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n                vec2 uv = gl_FragCoord.xy / uResolution;\n                float particleDepth = getDepth(gl_FragCoord.z, uCameraNear, uCameraFar);\n                float sceneDepth = getDepth(tDepth, uv, uCameraNear, uCameraFar);\n                float alphaScale = fadeEdge(particleDepth, sceneDepth);\n                tex.a *= alphaScale;\n                tex.a *= vFade;\n                tex.a *= uAlpha;\n\n                gl_FragColor = tex;\n            }\n        `;class Dust extends Group{constructor(e){super(),this.numParticles=e,this.initPoints()}initPoints(){const{camera:e,getTexture:r,resolution:n,time:t}=WorldController,a=[];for(let r=0;r<this.numParticles;r++)a[3*r+0]=MathUtils.randFloatSpread(e.far),a[3*r+1]=MathUtils.randFloatSpread(e.far),a[3*r+2]=MathUtils.randFloatSpread(e.far);const i=new BufferGeometry;i.setAttribute("position",new BufferAttribute(new Float32Array(a),3));const o=new RawShaderMaterial({uniforms:{tMap:new Uniform(r("assets/textures/particle.png")),tDepth:new Uniform(null),uScale:new Uniform(Stage.dpr/2),uAlpha:new Uniform(1),uCameraNear:new Uniform(e.near),uCameraFar:new Uniform(e.far),uResolution:n,uTime:t},vertexShader:vertexDustShader,fragmentShader:fragmentDustShader,transparent:!0,blending:AdditiveBlending,depthWrite:!1,depthTest:!1}),l=new Points(i,o);this.add(l),this.material=o}}class SceneView extends Group{constructor(){super(),this.initMesh()}async initMesh(){const{loadSphericalCubeTextures:e,loadEnvironmentTexture:r}=WorldController,n=getSphericalCube(1,32);n.attributes.uv2=n.attributes.uv;const[t,a,i,o]=await Promise.all([e("assets/textures/pbr/pitted_metal_basecolor.jpg"),e("assets/textures/pbr/pitted_metal_normal.jpg"),e("assets/textures/pbr/pitted_metal_orm.jpg"),r("assets/textures/env.jpg")]),l=[];for(let e=0;e<6;e++)l[e]=new MeshStandardMaterial({color:Config.BG_COLOR,roughness:1,metalness:1,map:t[e],aoMap:i[e],aoMapIntensity:1,roughnessMap:i[e],metalnessMap:i[e],normalMap:a[e],normalScale:new Vector2(1,1),envMap:o,envMapIntensity:.5});const s=new Mesh(n,l);s.scale.x=-1,this.add(s)}}class RenderManager{static init(e,r,n,t){this.renderer=e,this.scene=r,this.camera=n,this.dust=t,this.luminosityThreshold=.1,this.bloomStrength=.3,this.bloomRadius=.75,this.enabled=!0,this.initRenderer()}static initRenderer(){const{resolution:e,screenTriangle:r}=WorldController;this.renderer.autoClear=!1,this.screenScene=new Scene,this.screenCamera=new OrthographicCamera(-1,1,1,-1,0,1),this.screen=new Mesh(r),this.screen.frustumCulled=!1,this.screenScene.add(this.screen),this.renderTargetA=new WebGLRenderTarget(1,1,{format:RGBFormat,anisotropy:0,depthBuffer:!1}),this.renderTargetB=this.renderTargetA.clone(),this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5,this.renderTargetBright=this.renderTargetA.clone();for(let e=0,r=this.nMips;e<r;e++)this.renderTargetsHorizontal.push(this.renderTargetA.clone()),this.renderTargetsVertical.push(this.renderTargetA.clone());this.renderTargetA.depthBuffer=!0,this.renderTargetA.depthTexture=new DepthTexture,this.fxaaMaterial=new FXAAMaterial,this.fxaaMaterial.uniforms.uResolution=e,this.luminosityMaterial=new LuminosityMaterial,this.luminosityMaterial.uniforms.uLuminosityThreshold.value=this.luminosityThreshold,this.blurMaterials=[];const n=[3,5,7,9,11];for(let e=0,r=this.nMips;e<r;e++)this.blurMaterials.push(new UnrealBloomBlurMaterial(n[e])),this.blurMaterials[e].uniforms.uResolution.value=new Vector2;const t=[1,.8,.6,.4,.2];for(let e=0,r=this.nMips;e<r;e++){const r=t[e];t[e]=this.bloomStrength*mix(r,1.2-r,this.bloomRadius)}this.bloomCompositeMaterial=new BloomCompositeMaterial(this.nMips),this.bloomCompositeMaterial.uniforms.tBlur1.value=this.renderTargetsVertical[0].texture,this.bloomCompositeMaterial.uniforms.tBlur2.value=this.renderTargetsVertical[1].texture,this.bloomCompositeMaterial.uniforms.tBlur3.value=this.renderTargetsVertical[2].texture,this.bloomCompositeMaterial.uniforms.tBlur4.value=this.renderTargetsVertical[3].texture,this.bloomCompositeMaterial.uniforms.tBlur5.value=this.renderTargetsVertical[4].texture,this.bloomCompositeMaterial.uniforms.uBloomFactors.value=t,this.dustScene=new Scene,this.dustScene.add(this.dust),this.dust.material.uniforms.tDepth.value=this.renderTargetA.depthTexture,this.compositeMaterial=new SceneCompositeMaterial,this.bokehBlurMaterial1=new BokehBlurMaterial1,this.bokehBlurMaterial1.uniforms.uResolution=e,this.bokehBlurMaterial2=new BokehBlurMaterial2,this.bokehBlurMaterial2.uniforms.uResolution=e,this.copyMaterial=new CopyMaterial}}RenderManager.resize=(e,r,n)=>{RenderManager.renderer.setPixelRatio(n),RenderManager.renderer.setSize(e,r),e=Math.round(e*n),r=Math.round(r*n),RenderManager.renderTargetA.setSize(e,r),RenderManager.renderTargetB.setSize(e,r),e=Math.round(e/2),r=Math.round(r/2),RenderManager.renderTargetBright.setSize(e,r);for(let n=0,t=RenderManager.nMips;n<t;n++)RenderManager.renderTargetsHorizontal[n].setSize(e,r),RenderManager.renderTargetsVertical[n].setSize(e,r),RenderManager.blurMaterials[n].uniforms.uResolution.value.set(e,r),e=Math.round(e/2),r=Math.round(r/2)},RenderManager.update=()=>{const e=RenderManager.renderer,r=RenderManager.scene,n=RenderManager.camera;if(!RenderManager.enabled)return e.setRenderTarget(null),e.clear(),void e.render(r,n);const t=RenderManager.screenScene,a=RenderManager.screenCamera,i=RenderManager.renderTargetA,o=RenderManager.renderTargetB,l=RenderManager.renderTargetBright,s=RenderManager.renderTargetsHorizontal,u=RenderManager.renderTargetsVertical;e.setRenderTarget(i),e.clear(),e.render(r,n),RenderManager.fxaaMaterial.uniforms.tMap.value=i.texture,RenderManager.screen.material=RenderManager.fxaaMaterial,e.setRenderTarget(o),e.clear(),e.render(t,a),RenderManager.luminosityMaterial.uniforms.tMap.value=o.texture,RenderManager.screen.material=RenderManager.luminosityMaterial,e.setRenderTarget(l),e.clear(),e.render(t,a);let d=l;for(let r=0,n=RenderManager.nMips;r<n;r++)RenderManager.screen.material=RenderManager.blurMaterials[r],RenderManager.blurMaterials[r].uniforms.tMap.value=d.texture,RenderManager.blurMaterials[r].uniforms.uDirection.value=BlurDirectionX,e.setRenderTarget(s[r]),e.clear(),e.render(t,a),RenderManager.blurMaterials[r].uniforms.tMap.value=RenderManager.renderTargetsHorizontal[r].texture,RenderManager.blurMaterials[r].uniforms.uDirection.value=BlurDirectionY,e.setRenderTarget(u[r]),e.clear(),e.render(t,a),d=u[r];RenderManager.screen.material=RenderManager.bloomCompositeMaterial,e.setRenderTarget(s[0]),e.clear(),e.render(t,a),e.setRenderTarget(o),e.render(RenderManager.dustScene,n),RenderManager.compositeMaterial.uniforms.tScene.value=o.texture,RenderManager.compositeMaterial.uniforms.tBloom.value=s[0].texture,RenderManager.screen.material=RenderManager.compositeMaterial,e.setRenderTarget(i),e.clear(),e.render(t,a),RenderManager.bokehBlurMaterial1.uniforms.tMap.value=i.texture,RenderManager.screen.material=RenderManager.bokehBlurMaterial1,e.setRenderTarget(o),e.clear(),e.render(t,a),RenderManager.bokehBlurMaterial2.uniforms.tMap.value=o.texture,RenderManager.screen.material=RenderManager.bokehBlurMaterial2,e.setRenderTarget(i),e.clear(),e.render(t,a),RenderManager.copyMaterial.uniforms.tMap.value=i.texture,RenderManager.screen.material=RenderManager.copyMaterial,e.setRenderTarget(null),e.clear(),e.render(t,a)};class WorldController{static init(){this.initWorld(),this.initLights(),this.initLoaders(),this.initControls()}static initWorld(){this.renderer=new WebGL1Renderer({powerPreference:"high-performance",stencil:!1}),this.element=this.renderer.domElement,this.renderer.toneMapping=ACESFilmicToneMapping,this.renderer.toneMappingExposure=1,this.scene=new Scene,this.scene.background=new Color(Config.BG_COLOR),this.camera=new PerspectiveCamera(30),this.camera.near=.5,this.camera.far=50,this.camera.position.z=6,this.screenTriangle=getFullscreenTriangle(),this.resolution=new Uniform(new Vector2),this.aspect=new Uniform(1),this.time=new Uniform(0),this.frame=new Uniform(0)}static initLights(){this.scene.add(new AmbientLight(16777215,.2)),this.scene.add(new HemisphereLight(6316128,4210752));const e=new DirectionalLight(16777215,.4);e.position.set(.6,.5,1),this.scene.add(e)}static initLoaders(){this.textureLoader=new TextureLoader,this.spherizeLoader=new SphericalCubeTextureLoader(this.renderer,!0),this.spherizeLoader.setOptions({size:512}),this.environmentLoader=new EnvironmentTextureLoader(this.renderer)}static initControls(){this.controls=new OrbitControls(this.camera,this.renderer.domElement),this.controls.enableDamping=!0,this.controls.enableZoom=!1}}WorldController.resize=(e,r,n)=>{WorldController.camera.aspect=e/r,WorldController.camera.updateProjectionMatrix(),e=Math.round(e*n),r=Math.round(r*n),WorldController.resolution.value.set(e,r),WorldController.aspect.value=e/r,WorldController.camera.position.z=e<r?10:6},WorldController.update=(e,r,n)=>{WorldController.time.value=e,WorldController.frame.value=n,WorldController.controls.update()},WorldController.getTexture=(e,r)=>WorldController.textureLoader.load(e,r),WorldController.loadTexture=e=>WorldController.textureLoader.loadAsync(e),WorldController.getEnvironmentTexture=(e,r)=>WorldController.environmentLoader.load(e,r),WorldController.loadEnvironmentTexture=e=>WorldController.environmentLoader.loadAsync(e),WorldController.getSphericalCubeTextures=(e,r)=>WorldController.spherizeLoader.load(e,r),WorldController.loadSphericalCubeTextures=e=>WorldController.spherizeLoader.loadAsync(e);class App{static async init(){Device.agent.includes("chrome")&&this.initThread(),this.initWorld(),this.initViews(),this.initControllers(),this.addListeners(),this.onResize()}static initThread(){ImageBitmapLoaderThread.init(),Thread.shared()}static initWorld(){WorldController.init(),Stage.add(WorldController.element)}static initViews(){this.view=new SceneView,WorldController.scene.add(this.view),this.dust=new Dust(4e3)}static initControllers(){const{renderer:e,scene:r,camera:n}=WorldController;RenderManager.init(e,r,n,this.dust)}static addListeners(){Stage.events.on(Events.RESIZE,this.onResize),ticker.add(this.onUpdate)}}App.onResize=()=>{const{width:e,height:r,dpr:n}=Stage;WorldController.resize(e,r,n),RenderManager.resize(e,r,n)},App.onUpdate=(e,r,n)=>{WorldController.update(e,r,n),RenderManager.update(e,r,n)},App.init();</script>
</body>
</html>
